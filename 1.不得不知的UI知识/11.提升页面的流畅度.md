#### 提升页面的流畅度

##### 监控页面的流畅度 FPS

```objc
//使用CADisplayLink，每次界面刷新的时候都会调用这个方法
- (void)tick:(CADisplayLink *)link {
    if (_lastTime == 0) {
        _lastTime = link.timestamp;
        return;
    }
    
    _count++; //count可以记录一段时间内调用了多少次这个方法
    NSTimeInterval delta = link.timestamp - _lastTime;
    if (delta < 1) return; //这一步保证delta是大于等于1s的，不论这个方法有没有进来、count有没有增加，时间总是在增加的。如果CADisplayLink没有错过1s时的那次调用时机，那么当delta为1的时候就会执行下面的代码，如果错过了这次时机delta会大于1s。但基本上可以认为delta就是1s。
    _lastTime = link.timestamp;
    float fps = _count / delta;//1s中进来的次数除以1s，就是fps
    _count = 0;
    
    CGFloat progress = fps / 60.0;
    UIColor *color = [UIColor colorWithHue:0.27 * (progress - 0.2) saturation:1 brightness:0.9 alpha:1];
    
    NSMutableAttributedString *text = [[NSMutableAttributedString alloc] initWithString:[NSString stringWithFormat:@"%d FPS",(int)round(fps)]];
    [text setColor:color range:NSMakeRange(0, text.length - 3)];
    [text setColor:[UIColor whiteColor] range:NSMakeRange(text.length - 3, 3)];
    text.font = _font;
    [text setFont:_subFont range:NSMakeRange(text.length - 4, 1)];
    
    self.attributedText = text;
}
```

##### 针对CPU进行优化

对象的创建、调整、销毁

预排版（布局计算、文本计算）

预渲染（文本等异步绘制、图片编解码等）

##### 针对GPU进行优化

纹理渲染：如果触发了离屏渲染，GPU做纹理渲染的工作量就会特别大。基于此，我们尽量避免离屏渲染就可以对GPU进行优化。同时还可以基于CPU的异步绘制机制来减轻GPU的绘制压力。

视图混合：比如视图非常复杂，比如有多个视图层层叠加，那么GPU就要做每一个视图的合成，合成每一个像素点对应的像素值，它就需要大量的计算。如果在一定程度上减轻视图层级的复杂性，也可以减轻GPU的压力。也可通过CPU的异步绘制机制来达到提交的位图本身就是一个层级非常少的视图。

#### UITableView优化

iOS8之后每次`dequeueReusableCellWithIdentifier:forIndexPath:`都会重新计算cell的高度

可以缓存cell高度，http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/