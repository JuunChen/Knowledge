#### 图像显示的原理 

CPU与GPU是通过总线连接起来的，在CPU中输出的结果往往是一个位图，在经由总线在合适的时机上传给GPU，GPU拿到位图后会做图层的渲染、纹理的合成，然后把结果放到帧缓冲区当中，视频控制器会在vsync信号到来之前去提取帧缓冲区中的内容，最终显示到手机屏幕上。

- 创建UIView对象时，UIView内部会自动创建一个图层即CALayer。
- CALayer中有一个属性contents，就是我们最终要绘制到屏幕上的一个位图。
- 在一个合适的时机，系统会调用UIView的drawRect:方法，我们可以绘制些想要自定义的内容。
- 绘制好之后 CoreAnimation 将绘制好的位图提交给GUP的OpenGL管线
- OpenGL进行最终的位图渲染，纹理的合成
- GPU 把结果放到帧缓冲区中

CUP

- Layout：UI布局，文本计算。比如控件frame的设置，label文字的计算等。
- Display：绘制阶段。比如drawRect:方法就发生在这一步
- Prepare：准备阶段。比如我们使用到了UIImageView，设置image的时候图片往往是不能直接显示到屏幕上的，需要对图片进行解码，解码的动作就发生在这一过程当中。
- Commit：提交。由CoreAnimation对CPU最终输出结果位图进行提交。

GPU渲染管线（OpenGL的渲染管线）

- 顶点着色：对位图进行处理

- 图元装配

- 光栅化

- 片段着色

- 片段处理

  完成之后将所有的像素点提交到帧缓冲区当中

#### UI卡顿掉帧的原因

Vsync 信号16.67ms到来一次，当Vsync到来时，如果帧缓冲区中没有内容，那么就会出现卡顿掉帧的效果。

在下一帧Vsync信号到来之前，CPU和GPU并没有共同完成下一帧画面的合成，就会导致卡顿或掉帧。

#### 如何提升UITableView的性能

##### 针对CPU进行优化

对象的创建、调整、销毁

预排版（布局计算、文本计算）

预渲染（文本等异步绘制、图片编解码等）

##### 针对GPU进行优化

纹理渲染：如果触发了离屏渲染，GPU做纹理渲染的工作量就会特别大。基于此，我们尽量避免离屏渲染就可以对GPU进行优化。同时还可以基于CPU的异步绘制机制来减轻GPU的绘制压力。

视图混合：比如视图非常复杂，比如有多个视图层层叠加，那么GPU就要做每一个视图的合成，合成每一个像素点对应的像素值，它就需要大量的计算。如果在一定程度上减轻视图层级的复杂性，也可以减轻GPU的压力。也可通过CPU的异步绘制机制来达到提交的位图本身就是一个层级非常少的视图。

#### 异步绘制的原理

#### 什么是离屏渲染

- layer.cornerRadius + layer.maskToBounds
- 阴影蒙层