1. 什么是 Runloop ? 它的作用是什？

   Runloop其实是一个对象，它内部维护了一套事件循环机制。

   > 可以保持线程的存活、保证程序的运行，没有 RunLoop 程序执行完就会推出。
   >
   > 可以处理App的各种事件

   > 有事做事，没事休眠 => 节省资源

2. 什么是事件循环机制？

   **没有消息需要处理时，休眠以避免资源占用**

   > 从用户态通过系统调用进入内核态

   **有消息需要处理时，立刻被唤醒**

   > 内核态切换到用户态

3. Runloop与线程的关系？

   一一对应的关系。它们保存在一个全局的字典里面，key是线程，value是RunLoop。
   
4. 使用场景

   **NSTimer**

   > NSTimer 默认是被加在 defaultMode 中的，切换到 UITrackingMode 的时候它就会失效
   >
   > Runloop任务比较繁重的话，会阻塞timer的调用

   **AutoreleasePool**

   > 系统创建的 AutoreleasePool 会在出 RunLoop 休眠前调用 AutoReleasePoolPage 的 pop 和 push。

   **PerformSelector: afterDelay:**

   > 该方法会创建一个 NSTimer 并添加到当前的 RunLoop 中，如果当前线程没有 RunLoop，则该方法不会触发。

   **线程保活**

   > 

   **页面渲染流程**

   > 当我们调用 `[UIView setNeedsDisplay]` 时，这时会调用当前 `View.layer` 的 `[view.layer setNeedsDisplay]`方法。
   >
   > 这等于给当前的 `layer` 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 `Runloop` 即将休眠，也就是 `beforeWaiting` 时才会进行绘制工作。

   **事件响应过程**

   > Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。
   >
   > `_UIApplicationHandleEventQueue()` 会把 `IOHIDEvent` 处理并包装成 `UIEvent` 进行处理或分发，其中包括识别 `UIGesture`/处理屏幕旋转/发送给 `UIWindow` 等。通常事件比如 `UIButton 点击`、`touchesBegin/Move/End/Cancel` 事件都是在这个回调中完成的

5. Runloop的observer

   ```objc
   typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
       kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
       kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
       kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
       kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
       kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
       kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
   };
   ```


