### 动态规划

简称DP，是求解最优化问题的一种常用策略。

**通常的使用套路**（一步步优化）：

1. 暴力递归（自顶向下，出现了重叠子问题）
2. 记忆化搜索（自顶向下）
3. 递推（自底向上）

### 零钱兑换问题

假设有25分、20分、5分、1分的硬币，现要找给客户41分的零钱，如何办到硬币个数最少？

如果使用贪心策略**每次都找最大的硬币**，得到的结果是5枚硬币，这并不是最优解。

使用动态规划可以得到最优解。

#### 假设 dp(n) 是凑到 n 分需要最少的硬币的个数

我们定义了这个假设，那么举个例子 dp(20) 就是凑到 20 分需要的最少的硬币的个数。dp(30) 就是凑到 30 分需要的最少的硬币的个数。那么 dp(41) 就是我们这道题目的解。

如果第 1 次选择了 25 分的硬币，那么 dp(n) = dp(n - 25) + 1

如果第 1 次选择了 20 分的硬币，那么 dp(n) = dp(n - 20) + 1

如果第 1 次选择了 5 分的硬币，那么 dp(n) = dp(n - 5) + 1

如果第 1 次选择了 1 分的硬币，那么 dp(n) = dp(n - 1) + 1

所以 **dp(n) = min {dp(n - 25), dp(n - 20), dp(n - 5), dp(n - 1)} + 1**

动态规划考虑了所有情况，所以能求出全局最优解。而贪心只考虑了当前最优，所以的出来的并不一定是全局最优解。

#### 暴力递归

我们定义一个函数`int coins(int n)`，它的作用是传入要凑到的金币数 n，返回最少的个数。我们将上述思路转换成代码：

```java
int coins(int n) {
  if (n == 0) return 0;
  if (n < 0) return Integer.MAX_VALUE;
  int dp_n_25 = coins(n - 25);
  int dp_n_20 = coins(n - 20);
  int dp_n_5 = coins(n - 5);
  int dp_n_1 = coins(n - 1);
  int min1 = Math.min(dp_n_25, dp_n_20);
  int min2 = Math.min(dp_n_5, dp_n_1);
  int min = Math.min(min1, min2);
  return min + 1;
}
```

现在只用调用`coins(41);`就能得到上面题目的答案。

上述方法属于动态规划的第一步**暴力递归**，分析上面的代码能看出这种方法实际上做了很多重复的的调用，比如coins(1)、coins(20)等等都可能会被调用多次！

#### 记忆化搜索

所谓记忆化搜索就是将已经计算过的值存起来，下次可以直接用，而不必再次计算。

比如在这道金币题中，我们将计算到的值存到数组`int[] dp`中，让dp[1] = dp(1)，dp[2]=dp(2)...，dp[41]=dp(41)。那么数组所需要的空间大小为`n + 1`，即`int[] dp = new int[n+1]`。每次计算dp(n)的时候判断如果dp[n]存在，则`dp(n)=dp[n]`，否则再去计算dp(n)，然后存到dp[n]中。

```java
int coins(int n) {
  if (n < 1) return -1;
  int[] dp = new int[n+1];
  return caculate(n, dp);
}

int caculate(int n, int[] dp) {
  if (n == 0) return 0;
  if (n < 0) return Integer.MAX_VALUE;
  if (dp[n] == 0) {
    int min1 = Math.min(caculate((n - 25), dp), caculate((n - 20), dp)); 
    int min2 = Math.min(caculate((n - 5), dp), caculate((n - 1), dp)); 
    dp[n] = Math.min(min1, min2) + 1;
  }
  return dp[n];
}
```

### 递推

递推广泛地说就是非递归，也有人称作迭代。

思路就是得到 `dp[1]` 到 `dp[n]`的值，然后直接返回 `dp[n]`。

```java
int coin(int n) {
  if (n < 1) return -1;
  int[] dp = new int[n+1];
  for (int i = 1; i < n+1; i++) {
    //dp[i] = min{dp[i-25],dp[i-10],dp[i-5],dp[i-1]} + 1
		int min = dp[i - 1];
    if (i>=5) min = Math.min(min, dp[i - 5]);
    if (i>=10) min = Math.min(min, dp[i - 20]);
    if (i>=25) min = Math.min(min, dp[i - 25]);
    dp[i] = min + 1;
  }
  return dp[n];
}
```

时间复杂度、空间复杂度都是O(n)