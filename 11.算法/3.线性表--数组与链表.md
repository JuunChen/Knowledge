

#### 线性表

常见的线性表有：数组、链表、栈、队列、哈希表（散列表）

#### 数组

**数组**是一种**顺序存储**的线性表，所有元素的内存地址是连续的。

动态扩容的实现方式：重新申请一个容量更大的数组，将旧数组的内容拷贝到新的数组。

#### 链表（Linked List）

动态数组有个明显的缺点：可能会造成内存空间的大量**浪费**（新扩容的空间可能会不被使用）。

**链表**是一种**链式存储**的线性表，所有元素的内存地址不一定是连续的。

```c
/**
 * Definition for singly-linked list.
 */
struct ListNode {
	int val;
	struct ListNode *next;
};
```

##### 时间复杂度对比

|                       |                数组                 |                链表                 |
| --------------------- | :---------------------------------: | :---------------------------------: |
| 查询index位置的元素   |                O(1)                 | 最好:O(1) \| 最坏:O(n) \| 平均:O(n) |
| 设置index位置的元素   |                O(1)                 | 最好:O(1) \| 最坏:O(n) \|平均:O(n)  |
| index位置插入一个元素 | 最好:O(1) \| 最坏:O(n) \|平均:O(n)  | 最好:O(1) \| 最坏:O(n) \|平均:O(n)  |
| index位置删除一个元素 | 最好:O(1) \| 最坏:O(n) \| 平均:O(n) | 最好:O(1) \| 最坏:O(n) \|平均:O(n)  |

有的文章说链表的添加和删除元素的时间复杂度是O(1)，其实并不是这样的，找到index的node过程就是需要耗时的。

链表的优势在于省内存。

数组在添加元素时，一般情况下时间复杂度是O(1)。但是遇到需要扩容时，会变成O(n)。这种情况要计算**均摊复杂度**，计算的结果是O(1)。

#####  题目1：删除节点

https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

```c
void deleteNode(struct ListNode* node) {
    node->val = node->next->val;
    node->next = node->next->next;
}
```

#####  题目2：反转链表

https://leetcode-cn.com/problems/reverse-linked-list

**递归解法：**

```c
struct ListNode* reverseList(struct ListNode* head){
    if (head == NULL || head->next == NULL) return head;
    struct ListNode *newNode = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return newNode;
}
```

- 如果head为空则返回空
- 如果head.next为空，则返回head
- 先把head.next反转了
- 再将head.next的next指向head
- 最后将head.next置空

**迭代解法：**

```c
struct ListNode* reverseList(struct ListNode* head){
    if (head == NULL || head->next == NULL) return head;
    struct ListNode *result = NULL;
    while(head){
        struct ListNode *currentNode = head;
        head = head -> next;
        currentNode->next = result;
        result = currentNode;
    }
    return result;
}
```

#####  题目3：判断一个链表是否有环

https://leetcode-cn.com/problems/linked-list-cycle/

```c
bool hasCycle(struct ListNode *head) {
    if(head == NULL || head->next == NULL) return false;
    struct ListNode *slow = head;
    struct ListNode *fast = head->next;
    while(fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

#### 栈

特点是后进先出，只能从一端操作。

括号匹配问题考虑使用栈的思路来解决。

#### 队列

只能在**头尾两端**进行操作。

- 队尾：只能从队尾添加元素，一般叫做enQueue，入队。
- 队头：只能从队头移除元素，一般叫做deQueue，出队。
- 先进先出原则。