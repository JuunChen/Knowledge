里 依 接 迪 单 开

##### 开闭原则

> 对修改关闭、对扩展开放

 当应用需求改变时，在不修改源代码的情况下，可以扩展模块的功能，使其满足新的需求。

1. 对软件测试的影响

软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

2. 可以提高代码的可复用性

粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

3. 可以提高软件的可维护性

遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

##### 接口隔离原则

> 一个类对另一个类的依赖应该建立在最小的接口上。使用多个专门的协议、而不是一个庞大臃肿的协议

尽量将臃肿庞大的接口拆分成更小的和更具体的接口。比如系统提供的 delegate 和 dataSource 协议。

##### 依赖倒置原则

> 模块不要直接依赖模块，要依赖于抽象。要面向接口编程，不要面向实现编程。

例子：

1. 上层业务不应该直接依赖下层的模块，应当依赖于抽象接口（抽象层是稳定的）

2. 很常见的例子 

   有个UI模块，比如说信息流吧

   它要展示数据，需要用户数据 UserModel

   我们要提供一个 setModel： 的方法，如果把参数的类型写死了

   以后别的model 比如广告model想用这个 UI 就用不了了

   解决办法：可以把UI模块需要的数据抽象一个协议出来，参数类型写遵循这个协议的id类型

##### 单一职责原则

> 一个类只负责一件事

比如系统提供的UIView和CALayer。

这里有个窍门得说一下，就是在写一个类中实现一段功能的时候，如果发现这段功能用到其它的类特别多，那么就需要考虑，是不是把这段功能放到其它类中更合适。



##### 里氏替换原则

> 继承必须确保超父所拥有的性质在子类中仍然成立。

子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

例子：

我们在开发中可以用父类指针指向子类对象

KVO

##### 迪米特法则

> 一个对象应当对其它对象尽可能少的了解

高内聚、低耦合。