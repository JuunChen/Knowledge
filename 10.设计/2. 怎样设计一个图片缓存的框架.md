#### 图片缓存的基本框架

<img src="https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/10-2-1-图片缓存基本框架.png" style="zoom:33%;" />

我们的图片缓存框架需要一个**管理者**来调度框架中的各个模块。

1. 需要一个**内存管理**模块来处理图片的内存缓存。

2. 需要一个**磁盘管理**模块来处理图片的磁盘缓存。

3. 如果本地没有图片的话，我们需要一个**网络模块**来下载图片。

这就构成了一个基本的图片缓存框架。

#### 具备编解码功能的框架

<img src="https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/10-2-2-图片解码.png" style="zoom:33%;" />

如果图片是经过压缩了的，或者是我们在内存中所保存的图片需要时解码过后的图片格式，那就需要再添加一个解码相关的管理者。

它下面又有两个模块

- 第一个模块负责图片解码
- 第二个模块负责图片压缩/解压缩

#### 图片读取的过程

<img src="https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/10-2-3-读取图片的过程.png" style="zoom:33%;" />

首先在内存模块中查找，如果命中，就将找到的图片返回给调用者，结束查找过程。

如果内存缓存没有命中，就需要进行磁盘的查找，如果命中就返回结果。

如果磁盘缓存没有命中，就需要进行网络下载。

为什么要设计内存模块？

这样做的好处是可以提升查找的效率。如果每次都从磁盘读，或者从网络下载，会增加耗时和流量上的损耗。

#### 内存设计上需要考虑哪些问题

首先要考虑的是**存储的Size**，我们不能说图片在内存中的缓存是无限大的空间，这样的话可能会由于图片非常占用内存可能会造成内存压力过大。

然后要考虑的是**淘汰策略**，既然有size的限制，那么必然当有新的图片需要缓存的话，就需要把以往的某些图片淘汰掉。主要有两种方案：

- 以队列先进先出的方式淘汰

- LRU算法（最近最久未使用算法）：可以理解为在固定时长之内它有没有使用过。可以根据这个考量标准来进行图片的淘汰。

  在实现这种淘汰方式的时候可以考虑**定时检查**：比如定时遍历图片列表，将固定时长内没有使用的图片删除。但是这是一种非常 low 的方式，因为定时检查本身就比较耗性能，这么做划不来。

  还可以使用另一种方式来实现，就是**提高检查触发频率**：1. 每次进行图片读写时触发 2.在前后台切换的时候

#### 磁盘设计需要考虑哪些问题

磁盘和内存相比，它的特点是：空间大、存取效率低。

首先要考虑的是**存储方式**

然后要考虑的是**大小限制**：比如限制大小为100M

最后要考虑的是**淘汰策略**：比如一图片存储时间距今已超过7天

#### 网络设计需要考虑哪些问题

首先要考虑的是**图片请求的最大并发量**：比如在同一时间最大请求的数量限制为6

然后要考虑的是**请求超时策略**：比如图片请求超时后，添加一次重试的机制

最后需要考虑的是**请求的优先级**：如果是用户急需的图片，那么它的优先级就要高一些

#### 图片解码

对于不同格式的图片，解码采用什么方式来做？

- 应当使用**策略模式**对不同格式图片进行解码

在哪个阶段做图片解码处理？

1. 磁盘读取后。放在磁盘中的是未解码的图片，读到内存中最好存储已解码的图片。因为系统在显示图片之前会在主线程进行图片解码操作，从磁盘读取之后进行解码放到内存当中，这样可以减少主线程的压力。
2. 网络请求返回后。

