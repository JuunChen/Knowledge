### HTTPS

> HTTPS<font color=#8e2323> **=**</font> HTTP <font color=#8e2323> **+**</font> SSL/TLS   HTTPS 是由 HTTP 和 SSL/TLS 共同组成的。

<font color=#8e2323> HTTPS的目的是让数据在传输过程中不使用明文，而是被加密的</font>。

基于这个目的，我们来梳理一下整个流程。

HTTPS想让数据在传输过程中加密，就只能选择对称加密。因为非对称加密性能太差。

那么至少需要一次网络传输，才能使客户端与服务端都拥有对称加密的秘钥！

如果在传输过程，秘钥被中间人获得到，那么HTTPS就没有了意义。

所HTTPS就想了一个办法：用非对称加密来加密要传递的对称加密的公钥。具体做法是在服务端存有非对称加密的公钥和私钥，客户端向服务端请求公钥，服务端返回给客户端公钥，客户端创建对称加密的秘钥，然后用公钥对秘钥进行非对称加密，然后传递给服务端。服务端通过自己的私钥对它进行解密，这样两端就都有对称加密秘钥了。

但是中间人也想了个办法：他将服务端返回的公钥存了起来，然后生成了一对假非对称加密秘钥，并把假公钥给客户端，

客户端用假公钥对自己生成的对称秘钥进行了加密，发送给了中间人，中间人用假私钥解密得到对称秘钥，并且用真公钥加密发送给了服务端，服务端与客户端都不知道中间人存在。中间人悄无声息地获得了他们的秘钥。

然后HTTPS又想了一个办法：创造了数字证书。客户端不再请求公钥，而是请求数字证书。数字证书中有签名，中间人不能篡改的！数字证书中还有公钥，客户端创建好秘钥后用公钥加密，传递给服务端。客户端与服务端就可以在传输数据的过程中使用对称秘钥进行加解密了。

中间人没办法了。

#### 应用层加密

即使HTTPS已经是安全的协议了。但是在应用层仍需对数据进行加密。

首先，SSL位于应用层和传输层之间，HTTPS只保证了SSL层之下的传输是加密的，而SSL层之上的应用层并不能保证，别人还有办法能拿到明文。

其次，中间人还有一种办法。他拦截到服务端返回到的证书后还可以**伪造证书**，只要客户端信任这个证书，他也能拿到客户端创建的公钥，也能明文查看数据。

### HTTPS 连接建立的流程

<img src="/Users/momo/Documents/Knowledge/ImageFolder/8-3-1-https.png" style="zoom:33%;" />

1. 客户端向服务端发送一个报文，这个报文包含三方面内容：

   > 1. 客户端支持的TLS协议版本号
   > 2. 客户端所支持的一些加密算法
   > 3. 一个随机数 C 

2. 服务端向客户端返回一个握手的报文消息，这个报文消息包含：

   > 1. 商定的加密算法 （比如客户端传过来3中它支持的算法，那么服务端会选择一个并告诉客户端）
   > 2. 随机数 S
   > 3. server证书

3. 客户端收到上述内容后首先会验证server证书来判定当前的servers是否是一个合法的server。这一步实际上就是对server端的公钥进行一个验证。
4. 之后客户端会组装会话秘钥。这个会话秘钥是有随机数C、S以及客户端产生的预主密钥来进行会话密钥的组装。
5. 客户端通过server的公钥对预主秘钥进行加密传输
6. server通过私钥解密得到预主秘钥
7. server通过随机数c和随机数s以及通过私钥解密得到的预主秘钥组装会话秘钥
8. 之后客户端给server端发送一个加密的握手消息
9. server再给客户端返回一个加密的握手消息来验证安全通道是否已经建立完成

##### 会话密钥的概念

> 会话秘钥 = random S + random C + 预主秘钥

