#### 慢开始与拥塞避免

发送方维护了一个叫做**拥塞窗口cwnd**的状态变量，其值取决于网络的拥塞程度，并且动态变化。

> 拥塞窗口的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些。
>
> 判断出现网络出现拥塞的依据：没有按时收到应当达到的确认报文（即发生重传）

发送方将拥塞窗口作为发送窗口，即 **swnd = cwnd**。

发送发还需要维护一个慢开始门限 **ssthresh** 状态变量：

> 当 cwnd < ssthresh 时，使用慢开始算法
>
> 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法
>
> 当 cwnd = ssthresh 时，两种算法都可以使用

举一个例子

起初拥塞窗口cwnd的大小为1，慢开始门限ssthresh的值为16。这时使用慢开始算法。

第一轮传递数据时cwnd为1

第二轮传递数据时cwnd为2

第三轮传递数据时cwnd为4

第四轮传递数据时cwnd为8

第五轮传递数据时cwnd为16

第六轮传递数据时，由于cwnd已经到达慢开始门限ssthresh的值16，这时会采取拥塞控制算法：每轮+1。这时cwnd的值回变为17。

第七轮传递数据时cwnd为18

...

直到出现了数据丢失，即发生了重传。这时ssthresh会变为cwnd的一半，然后cwnd变为1，重新开始慢开始算法。

![](/Users/momo/Documents/Knowledge/ImageFolder/8-9-1慢开始与拥塞避免.png)

#### 快重传与快恢复

慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。

1990年又**增加**了两个新的拥塞控制算法以改进TCP的性能，这就是快重传与快恢复。

> 有时，个别报文段会在网络中丢失，但实际上网络并没有发生拥塞。
>
> 这将导致发送方超时重传，并误认为网络发送了拥塞。
>
> 发送发错误地启动慢开始算法，并把拥塞窗口cwnd又设置为最小值1，因而降低了传输效率。

**快重传**就是使放松法尽快重传。大概思路是发送方能够知道自己发出的数据丢失了，然后就立即重传，而不是等到超时计时器超时再重传。

发送方立即重传时会执行**快恢复**算法：发送方将cwnd和ssthresh调整为当前窗口的一半，然后执行拥塞避免算法。

![](/Users/momo/Documents/Knowledge/ImageFolder/8-9-1快重传与快恢复.png)

