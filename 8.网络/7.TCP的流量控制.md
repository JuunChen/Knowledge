#### TCP利用滑动窗口机制实现流量控制

我们总是希望数据传输得更快一些。

> 但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。

所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用<font color=#8e2323>滑动窗口机制</font>可以在TCP连接上实现**对发送方的流量控制**。

#### TCP流量控制举例

假设主机A与主机B之间已经建立了TCP连接。A给B发送数据，B对A进行流量控制。 

主机A待发送的数据以字节为单位，每个单位都有序号，从序号1开始。

假设主机A发送的每个TCP数据报文段，可携带100字节数据，因此图中每个小格子表示100字节数据。

<img src="https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-1-A的报文.png" style="zoom:100%;" />

在主机AB之间建立TCP连接时，B告诉A，我的接收窗口RWnd=400，因此主机将自己的发送窗口也设置为400。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-2-A设置发送窗口.gif)

这意味着主机A在未收到主机B发来的确认时，可将序号落入窗口中的数据全部发送出去。

下面举例说明主机B对A的流量控制。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制 1.gif)

主机A将发送窗口内序号1到100的数据封装成TCP报文段发送出去，发送窗口内还有300字节可以发送。

`seq`是TCP首部中的序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号为1。

`DATA`表示这是TCP数据报文段。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制2.gif)

主机A将发送窗口内序号101到201的数据封装成TCP报文段发送出去，发送窗口内还有200字节可以发送。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制3.gif)

主机A将发送窗口内序号201到300的数据封装成TCP报文段发送出去，但该报文段在传输过程中丢失了，发送窗口内还有100字节可以发送。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制4.gif)

主机B对A发送的201号以前的数据进行累计确认，B将自己的接收窗口调整为300，并通告A（对A进行流量控制）。

这里的`ACK`是TCP首部中的标志位，取值1表示这是一个TCP确认报文段。

`ack`是TCP首部中的确认号字段，取值201表示序号201之前的数据已全部收到，现在期望收到201及其后续数据。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制5.gif)

主机A收到该累计确认后，将发送窗口向前滑动。

使已发送并收到确认的这些数据的序号移除发送窗口。

由于主机B在该累计确认中奖自己的接收窗口调整为300，因此主机A相应地将自己的发送窗口调整为300。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制6.gif)

目前主机A发送窗口内的序号为201~500，也就是主机A还可以发送者300字节。

其中201到300字节是已发送的数据。若重传计数器超时，他们会被重传。

301~400号字节以及401~500号字节，还未被发送，可被分别封装在一个TCP报文段中发送。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制7.gif)

主机A现在可将发送缓存中，序号1~200的字节数据删除。因为已经收到了主机B对他们的累计确认。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制8.gif)

主机A对序号301到400的字节数据，封装成一个TCP报文段发送出去，还能发送100字节。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制9.gif)

主机将发送窗口内序号401~500的数据，封装成一个TCP报文段发送出去。

至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。

![](https://raw.githubusercontent.com/JuunChen/Knowledge/master/ImageFolder/8-7-3-B对A流量控制10.gif)

现在，发送窗口内序号201~300这一百字节的重传计时器超时了。主机A将它们重新封装成了一个TCP报文段发送出去，但是不能发送其它数据。

![]()

主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认。

并在该累计确认中将窗口字段的值调整为100（对A进行流量控制）。

![]()

主机A收到该累计确认后，将发送窗口向前滑动。使已收到累计确认的数据的序号移出发送窗口。

![]()

主机B在该累计确认中，将自己的接收窗口调整为了100。因此，主机A在将自己的发送窗口调整成了100。

![]()

目前，发送窗口内的序号为501~600。也就是主机A还可以发送这100字节。

![]()

现在主机A可以将发送缓存中序号201~500字节的数据全部删除了。因为已经收到了主机B对它们的累计确认。

![]()

主机A对序号501~600的字节数据，发送出去。

至此，序号落在发送窗口内的数据已经全部发送出去，不能再发送新数据了。

![]()

主机B收到主机A发送的数据后，对601号以前的数据进行累计确认。并在该累计确认中将窗口字段的值调整为0（对A进行流量控制）。

![]()

主机A收到该累计确认后将发送窗口向前滑动，使已发送并收到确认的数据移出发送窗口。

![]()

主机B在该累计确认中将自己的窗口调整为了0，因此，主机A相应的将自己的发送窗口调整为了0。

![]()

目前，主机A不能再发送一般的TCP报文段了。

![]()

主机A可将发送缓存中501~600的数据全部删除了。因为已经收到了主机B对他们的累计确认。

![]()

假设，主机B向A发送了0窗口的报文段后不久，B的接收缓存又有了一些存储空间。

于是B向A发送了 rwnd=300 的报文段，然而这个过程中报文段丢失了。

> A一直等待B发送非0窗口的通知，而B一直等待A发送的数据。如果不采取措施，这种互相等待而形成的死锁局面会一直持续下去。
>
> 为了解决这个问题，TCP为每一个连接设有一个持续计时器，只要TCP一方收到对方的0窗口通知，就启动持续计时器。若持续计时器超时就发送一个0窗口探测报文，仅携带0字节的数据。而对方在确认这个探测报文段时，给出自己现在的窗口值。
>
> 如果窗口仍然是0，那么收到这个报文段的一方就重新启动持续计时器。
>
> 如果窗口不是0，死锁的僵局就可以被打破了。

![]()

主机A收到B的0窗口通知后启动一个持续计时器。

![]()

当持续计时器超时，A发送0窗口探测报文段。

![]()

B窗口对发来的0窗口探测报文进行确认，并告知自己的接收窗口（假设仍为0）

![]()

主机A再次收到一个0窗口通知，再次启动一个0窗口计时器。

![]()

当持续计时器超时，主机A立刻发送0窗口探测报文。

![]()

假设B的接收缓存又有了一些存储空间，将自己的接收窗口调整为了300。主机B就在确认这个0窗口探测报文段时，给出自己现在的窗口值为300，这样就打破了死锁的局面。

