### HTTP 超文本传输协议

#### 请求/响应报文

> 请求报文
>
> ```c
> 方法 URL 协议版本 CRLF
> 首部字段名:值 CRLF
> 首部字段名:值 CRLF
> CRLF
> 实体主体
> ```

> 响应报文
>
> ```c
> 版本 状态码 短语
> 首部字段名:值 CRLF
> 首部字段名:值 CRLF
> CRLF
> 实体主体
> ```

>POST 与 GET 的区别？
>
>- GET 请求把参数拼接在 URL 中，POST 请求参数写在请求体中
>- GET 请求的参数长度有限制，POST 一般没有限制
>- POST 相对安全
>  - 浏览器可以保存浏览记录，如果使用 GET 请求，很容易被别人看到参数信息
>  - 服务器会记录请求记录，如果服务器被攻破，很容易拿到 GET 请求中的参数信息
>- 从语义上讲 GET 请求是查询数据，不应该引起服务端的状态变化，而且执行多次和执行一次的效果完全相同。POST 请求是改数据，是可以引起服务端状态变化的。

#### 连接建立流程

<img src="/Users/momo/Documents/Knowledge/ImageFolder/8-2-1-HTTP连接建立流程.png" style="zoom:25%;" />

1. 三次握手建立TCP连接

   > A. 客户端发送SYN报文
   >
   > B. 服务端回复SYN, ACK报文
   >
   > C. 客户端回复ACK报文

2. 进行HTTP数据的请求和响应

   > A. 客户端发送HTTP请求报文到服务端
   >
   > B. 服务端回复HTTP响应报文到客户端

3. 完成数据交换之后进行TCP的四次挥手

   > A. 客户端主动发起FIN终止报文到服务端
   >
   > B. 服务端收到终止报文之后回复ACK报文到客户端。此时客户端到服务端的连接就已经断开了。但是服务端到客户端可能还会传递数据。
   >
   > C. 在某一时机，服务端向客户端发送终止报文FIN和ACK
   >
   > D.客户端回给服务端一个ACK确认报文

4. 为什么需要三次握手，而不是两次？

   > 第一次握手服务端可以确认客户端能够发送报文
   >
   > 第二次握手客户端可以确认服务端能够发送和接收报文
   >
   > 第三次握手服务端能够确认客户端可以接收报文
   >
   > https://www.cnblogs.com/heyonggang/p/11634228.html

5. 为什么需要四次挥手，而不是三次？

   >前两次挥手关闭了客户端向服务端的通道
   >
   >此时，服务端有可能还要向客户端发送数据
   >
   >所以要等一会，服务端向客户端发送断开连接的报文，通过两次握手断开连接

6. 为什么第四次挥手时，客户端会等待2MSL再断开连接？

   > 为了保证服务端能收到客户端发送的最后一个报文。因为这个报文有可能丢失，服务端如果没收到会超时重传断开连接的报文，客户端收到后会重新发送确认报文，并重启定时器。这套机制保证两边都能正常断开连接。

#### HTTP的特点

1. 无连接

   客户端每次在进行数据交互前都会三次握手创建TCP通道，之后四次挥手关闭连接。

   **HTTP 的持久连接**

   含义：客户端与服务端建立好TCP连接通道后，在一定时间内，多个HTTP请求可能是在这同一个通道上进行数据传递的。这种连接复用的机制可以减少TCP连接的数量，减少建立/断开连接的次数，提升性能。

   **可以设置的头部字段：**

   Connection : keep-alive  表示客户端希望使用持久连接

   time : 20  表示连接会持续多久，比如20秒之内不会四次挥手

   max : 10 表示这条连接最多可以交换多少对HTTP请求和响应对

   **怎样判断一个请求是否结束？**

   a. 响应报文的首部字段中有`Content-length:`字段，它表示响应数据的大小。客户端可以根据这个字段的值来判断。

   b. `chunked`，最后会有一个空的chunked。

2. 无状态 

   在多次发送HTTP请求的时候，如果是同一个用户的话，server端是不知道它是同一个用户发送的。

   > 解决方案：Cookie/Session

